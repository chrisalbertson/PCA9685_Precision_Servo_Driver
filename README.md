# PCA9685 Precision Servo Driver

This is a driver for R/C servos that are connected to a PCA9685 chip.  The driver is efficient and allows for the servo motion to be calibrated. It also can enforce limits on motion range.

### Overview

R/C hobby servos are not consistent across brands or models.  They have their center points, range of motions and  amount of motion in relation to the pulse width is not constant.    One notable error source occurs because the servo's output shaft has a spline, we can never get the alignment between the servo and the robot part perfect, there is usually an "off by one tooth" assembly error.  With the supplied calibration program, the servos can be commanded to move and then the command and the actual movement are entered into a calibration table.  The table is stored in a file.    Later, when the robot controller is running and using this servo driver, the driver uses the calibration file to compensate for error inherent to the servo and any assembly error cause by the spline or inaccurate parts.  Because the calibration file is made by sending a commanded movement and then measuring how the robot moves, all error is accounted for.

The calibration file can be created quickly.  A file that uses reasonable defaults is included and can be used.  The user can make a simple customized file by changing a few default values and setting motion limits that are specif to the project.  Perhaps because some servos have a 270 range instead of the usual 180 degree range.   The zero points are also easy to move.     If the user has more time and patience he can command the servo to move to a set of arbitrary angles and measure the actual movement with a protractor.   Any number of these measurements can be made and the software will compute a least squares fit to the data points and use the fitted function to calibrate the servo.  The measured point and fitted function can be displayed on a graph.  This make spotting outliers (measurement errors and typos) easy.

The other feature of this driver is efficiency.  As much of the computation as possible is pushed into the calibration and start-up code.  This minimizes the amount of work to be done in real-time.  The servo driver accepts angles in radians in the robot's coordinate system and then directly converts this to pulse width in microseconds.  There is also an option to pass up to 16 angles for 16 servos in one call.    Numpy's vector arithmetic can then be used to advantage to transform all 16 angles to pulse widths and range limits. without need for Python loops and if statements.  If this feature is used, this driver is dramatically more efficient than others.

In a typical robot controller there are some trig functions that compute the desired joint angle in radians.  Then the radians are converted to degrees and then some offset is applied that compensates for how the servos are installed in the robot. Finally this is sent to a servo driver where the degrees are translated to "counts" the determine the with of a PWM pulse.   Then this entire chain of events is repeated for the next servo until all angles are set.     This driver will accommodates the this design but allows a for a faster method.  In the preferred use case, the robot software will still use the same trig functions, but will compute the angles in radians for up to 16 joints.  It would then send an array of all 16 angles to the driver.  The driver then uses a vector math package to translat all 16 angles to "counts" using a separate calibration function for each servo in a single step the commands are sent to all 16 servoes with a single "block write" on the I2C bus.

### Installation and usage

The simplest way to install this driver is to copy all the files into your project's folder.